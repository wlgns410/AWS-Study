# SQS Queue Detail & FIFO


## Message Visibility Timeout

<br>

기본 메시지 가시성 시간 초과는 30초이다.  
다른 유저가 메시지를 요청하면 리턴되지 않는다.  
즉, 어떤 유저가 요청한 메시지가 다른 소비자에게 보이지 않는다는 뜻이다.  
메시지가 삭제되지 않았다면 메시지를 다시 대기열에 넣고 같은 유저가 다시 호출을 하게 되면 이전의 그 메시지를 또 받게 된다.  
따라서 이전의 메시지가 전송되지 않았다면, 메시지가 두번 처리될 수 있다는 것을 알아야한다.  

<br>

---

<br>

## Dead Letter Queue(DLQ)

<br>

메시지에 문제가 있다거나 컨슈머(소비자)가 메시지를 이해하지 못하거나 처리하지 못하는 상태에 있을 때 DLQ가 일어난다.  
그러면 메시지는 다시 대기열로 돌아가고 같은 일이 반복되어진다.  
그렇기 때문에 이 반복횟수에 임곗값을 제한할 수 있다.  

<br>

DLQ는 메시지가 다른 대기열로 가면, 이 역시 SQS 대기열이라 처리해야하는데, 그동안 디버깅을 통해 문제를 파악할 시간이 생기기 때문에 유용하다.  

<br>

이 때 `Redrive to Source`를 사용하면 된다.  
메시지를 직접 검사하고 디버깅하려고 할 때, 실패 메시지 대기열에 잇는 메시지를 Source SQS 대기열로 redrive할 수 있다.   
그러면 컨슈머는 메시지가 실패 메시지 대기열에 들어갔고 메시지 처리 작업을 시도했었다는 것도 모른 채 메시지를 재처리한다.  

<br>

![스크린샷 2023-06-25 오전 9 20 35](https://github.com/wlgns410/AWS-Study/assets/81137234/03c3b7ee-6cc4-47de-afe3-ab172d6bc753)

<br>

위의 리드라이브와 배달 못한 대기열을 활성화한다.  

<br>

![스크린샷 2023-06-25 오전 9 21 33](https://github.com/wlgns410/AWS-Study/assets/81137234/c9bf9c02-6e71-4681-b7d2-1317f84de733)
![스크린샷 2023-06-25 오전 9 21 53](https://github.com/wlgns410/AWS-Study/assets/81137234/6310c3aa-f723-489b-9666-7eea1b9100d9)

<br>

표시 제한시간을 3초로 짧게 주고, 최대 수신 수를 4개로 지정한다.  
메시지를 3회 읽은 상태에서 4번째로 큐에 돌아가게 되면 DLQ로 들어가게 된다.  
이러면 3초 간격으로 메시지가 전송되게 되고 4번째 메시지는 DLQ로 전송되게 될 것이다.   

<br>

Redrive는 `Start DLQ Redrive`를 누르면 DLQ로 간 메시지가 다시 전송되게 되며 `Dead-letter queue redrive tasks` 항목에서 상태를 확인해보면  
작업이 정상적으로 완료되었는지 아닌지 status를 확인할 수 있다.  
그 다음 다시 `Pull for messages`를 누르면 DLQ로 간 메시지를 다시 받을 수 있음을 알 수 있다.

<br>

---

<br>

## Delay Queue

<br>

이는 메시지 전송을 할 때 대기열에 대한 시간을 지연시킬 수 있는 기능이다.  

<br>

![스크린샷 2023-06-25 오전 9 29 13](https://github.com/wlgns410/AWS-Study/assets/81137234/030a63fe-6757-41ce-a3ba-c089b67e1c42)

<br>

지연 시간을 10초로 지정했다.  
그러면 소비자는 10초를 기다린 후에 메시지를 받을 수 있게 된다.  
메시지 발신 시점과 실제 도착 시점 사이에 지연이 존재한다.  
상황에 따라 위 기능이 필요한 때가 있으니 잘 활요하면 된다.

<br>

---

<br>

## Long Polling

<br>

![스크린샷 2023-06-25 오전 9 51 15](https://github.com/wlgns410/AWS-Study/assets/81137234/22b80c27-5e4b-4ec3-803e-c604db5ac894)
![스크린샷 2023-06-25 오전 9 51 23](https://github.com/wlgns410/AWS-Study/assets/81137234/035a0224-de75-4619-a184-9bca76a9fc8e)

<br>

소비자가 SQS로부터 메시지를 요청할 때, 대기열이 비어있다면 메시지가 도착할 때까지 기다리게 할 수 있다.  
이를 롱폴링이라고 한다.  
0일때 숏폴링이고, 1 이상으로 바꾼 후부터는 롱폴링이 된다.

<br>

Long Polling은 대기열로 보내는 API 호출을 줄일 수 있다.  
메시지가 SQS 대기열에 도착하자마자 SQS 대기열이 이를 소비자에게 전송한다.  
API 호출을 줄일 수 있기 때문에 효율성이 향상되고 결과적으로 CPU 연산도 적어진다.  
또한 SQS 대기열이 메시지를 수신함과 동시에 소비자도 수신하게 되므로 지연 시간도 줄일 수 있다.  

<br>

통상적인 애플리케이션에서는 Short Polling 보다는 Long Polling이 추천된다.  
너무 많은 호출을 보내서 그로 인해 비용이 발생하고 CPU 연산이 늘어나며 지연시간이 길어지는 것을 방지하기 위함이다.  

<br>

`WaitTimeSeconds` 설정을 통해 API 호출 레벨에서 활성화할 수도 있다.   

<br>

---

<br>

## Extended Client

<br>

최대 메시지 크기 제한이 256KB이다.  
더 많은 용량을 보내기 위해서는 JAVA Library인 `SQS Extended Client`를 사용하면 된다.  
S3 버켓을 대용량 데이터로 담는 레포지토리로 사용하는 일을 하는 라이브러리이다.  

<br>

제작자가 SQS로 대용량 메시지를 보내려고 할 때,  
대용량 메시지가 S3에 도착하게 된다.  
SQS 대기열로 보내지는 것은 S3 버킷에 들어있는 대용량 메시지에 대한 포인터를 가진 작은 메타데이터 메시지이다.  
따라서 SQS 대기열은 작은 메시지를 포함하고 S3 버킷이 대용량 객체를 포함하게 되는 것이다.  
그리고 소비자가 SQS Extended Client 라이브러리를 사용해 SQS 대기열로부터 메시지를 읽는 시점에 그 소비자는 S3로 가서 더 큰 메시지를 읽으라고 말하는 데이터 메시지를 읽는 것이다.  
이렇게 소비자는 S3로부터 대용량 메시지를 가져와서 읽을 수 있게 된다.  

<br>

이는 흔히 비디오 파일을 처리할 때 많이 사용하는 기능이다.  
전체 비디오 파일을 SQS로 보내는 것이 아니라 S3에 저장하고 비디오 파일에 대한 포인터가 포함된 작은 메시지를 SQS 대기열로 보내서 S3에서 비디오를 가져오게 하는 것이다.  

<br>

---

<br>

## Must Know API

<br>

- CreateQueue : 큐 생성(MessageRetentionPeriod 함수 사용)
- DeleteQueue & PurgeQueue : 큐 삭제
- SendMessage : 메시지 전송(DelaySeconds 함수 사용)
- ReceiveMessage : 소비자가 메시지 받을 때
- DeleteMessage : 메시지 삭제
- MaxNumberOfMessages : 받을 메시지의 양 제한
- ReceiveMessageWaitTimeSeconds : Long Polling
- ChangeMessageVisibility : 메시지 처리 시간이 더 필요할 경우 사용

<br>

---

<br>

## FIFO Queue

<br>

선입선출이라는 뜻으로 첫번째로 대기열에 들어온 메시지가 대기열을 떠날 때도 첫번째가 되도록 대기열 내 순서가 정렬된다는 의미이다.  
따라서 표준 대기열보다 더 순서가 보장된다.  
순서에 대한 강제적인 보장이 존재하기 때문에 제한된 처리량을 가지게 된다.  
batch(묶음)일 때는 초당 300 msg/s 의 처리량이고  
batch가 아닐 때는 초당 3000 msg/s 의 처리량을 가지게 된다.  

<br>

![스크린샷 2023-06-25 오전 9 56 36](https://github.com/wlgns410/AWS-Study/assets/81137234/bcb013d5-28cb-4054-acd8-b762b365d7c4)
![스크린샷 2023-06-25 오전 9 57 35](https://github.com/wlgns410/AWS-Study/assets/81137234/26181e79-6242-48e9-8130-f3b72ae581f9)

<br>

이름은 .fifo를 붙여야 FIFO로써 만들어진다.  
대기열에 대한 커스터마이징이 가능하다.  
중복을 방지할 수도 있고, 처리량을 높일 수도 있다.  

<br>

메시지를 보낼 때, 
`Message group ID`를 입력할 수 있는데, 해당 그룹별로 처리량 한도나 중복 제거 범위를 지정할 수 있다.
`Message deduplicate ID`는 메시지 별로 고유한 ID로 이를 가지고 중복을 제거하는 방법으로 사용한다.

<br>

---

<br>

## FIFO - Deduplication

<br>

중복제거가 적용되는 간격은 5분이다.  
5분이내에 같은 메시지가 전송되면 두번째 메시지는 거부된다.  

첫뻔째는 Content-based deduplication이다.  
이는 SHA-256 알고리즘을 사용하여 해시가 계산된다.  
동일한 메시지가 보내지는 경우 해시 역시 동일하게 두 번 발생하게 된다.  

<br>

두번째는 Deduplication ID이다.  
동일한 중복제거 ID가 동일하게 반복되면 메시지가 거부된다.  

<br>

---

<br>

## FIFO - Message Grouping

<br>

메시지를 보낼 때 필수적으로 입력해야하는 파라미터이다.  
동일한 그룹으로 지정해서 입력하면 한 명의 소비자를 위해 모든 메시지들이 순서대로 정렬된다.  
하지만 Subnet 수준에서 메시지를 정렬할 필요가 있다면 메시지 그룹을 다르게 입력해야한다.  
이 정렬은 병렬적으로 일어나며 각기 다른 그룹에 대한 정렬이 동시에 일어난다는 뜻이다.  

<br>
